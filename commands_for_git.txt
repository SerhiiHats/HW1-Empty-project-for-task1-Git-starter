//уровни настройки git
system              -системный для всех юзеров
global              -пользовательский конкретного юзера
(.git/config)       -проектный в репозитории проекта

//первоначальная настройка git 
$ git config --global user.name "Serhii"              -добавление данных о пользователе
$ git config --global user.email gatsserv@gmail.com   -добавление почты пользователя

//просмотр всех настроек
$ git config --list

//создание комитов
$ git init                                 -инициализация пустого репозитория
$ git status                               -статус файлов в папке
$ git add .                                -добавление файлов под контроль git
$ git commit -m "first commit"             -создание комита
$ git log                                  -информация о комитах
$git log --oneline                         -выведет информацию о всех коммитах в сокращенном названии


$ git giff                                 -информация о изменениях кот.не были закомичены
$ git giff --staged                        -информация о изменениях но в области индекса (add .)
$ git giff --cached                        -информация о изменениях но в области индекса (add .) равносильна предыдущей

$ git commit -a -m "secondary commit"      -альтернативная команда создания комита add+commit
$ git log -p                               -вывод всех изменений в проекте
$ git log -n2                              -вывод последних двух коммитов
$ git log --grep secondary                 -поиск комита по части названия
$ git help                                 -вывод всех основних команд git
$ git checkout 42a1                        -переключение между комитами в комит с хешем 42а1
$ git checkout master                      -переход в master последнюю актуальную версию

//Ветвления и слияния merge последовательность действий
$ git branch bugfix                         -создаем ветку bugfix
$ git checkout bugfix                       -переходим на ветку bugfix (делаем там свою часть работы)
$ git commit -a -m "commit bugfix"          -создаем комит в ветке bugfix
$ git checkout master                       -переходим на ветку master
$ git merge bugfix                          -делаем слияние ветки master с bugfix
$ git branch                                -вывод всех веток кот. есть в проекте
$ git branch -d bugfix                      -удаление ветки bugfix

//слияние и rebase последовательность действий	
$ git branch bugfix                         -создаем ветку bugfix
$ git checkout bugfix                       -переходим на ветку bugfix (делаем там свою часть работы)
$ git commit -a -m "commit bugfix"          -создаем комит в ветке bugfix
$ git rebase bugfix                         -перемещаем ветку bugfix в конец ветки master (rebase)
$ git checkout master                       -переходим на ветку master
$ git merge bugfix                          -делаем слияние ветки master с bugfix

//загрузка на удаленный репозиторий
$ git remote add origin +(url)              -связь локального репозитория с удаленным
$ git push -u origin master                 -загрузка локального репозитория на удаленный 


/работа с удаленным репозиторием
$ git push                                  -отправляет все изменения на репозиторий 
$ git pull                                  -загружает обновления с удаленного репозитория, а также их интегрирует с локальным. 
$ git fetch                                 -загружает обновления с удаленного репозитория, но не интегрирует их с локальным.
$ git clone +(url)                          -склонирует удаленный репозиторий в папку на которой открыт git
$ git push --forse                          -перезатрет твои изменения на <remote> на удаленном репозитории с локального
.gitignore                                  -файл в который записывают неотслыживаемые файлы (*.a, !lib.a, /TODO, build/, doc/*.txt, ...)
                                            .gitignore - хорошо работает с теми что еще не проиндексированы и не отслеживаются
                                            Чтоб убрать из области коммитта файл и убрать из остлеживываемы и поместить в .gitignore
                                            начала $ git rm --cached +(namefile) это выведет файл из области коммита и поместит в измененные (modified)
                                            в это время добовляем этот файл в .gitignore и снова делаем add . + commit файл больше не будет отслеживаться

/удаление + переименование файлов
(можно делать в ручную а потом add . + commit)
$ git rm +namefile                                        -удаляет файл + делает индекс (add .) потом надо + commit
$ git mv +namefile                                        -переименовывает файл + делает индекс (add .) потом надо + commit

/откат не индексированной области(рабочей) до add .
$git restore nameFile ($git restore .)                    - откат тех изменений которые еще не были проиндексировани (modifided)

//откат в индексированной области(рабочей) после add . до commit -m (stoged)
$git restore  --staged nameFile ($git restore  --staged .)     - вывод из под индекса состояния (stoged) до состояния (modifided)
$git restore nameFile ($git restore .)                         - откат изменений которые в состоянии непроиндексированые (modifided)

//откат в закоммиченной области после commit -m 
//можно еще один commit присоединить к последнему и тогда последний перетрет предпоследний
$git commit --amend -m "add new commit"      - присоединение коммита к последнему(перетирание) в место старого коммита будет новый с именем "add new commit"
$git commit --amend -m "rename commit"       - эту же комманду можно использовать для изменения просто названия последнего коммита если обнаружилась ошибка

//достать файл из предыдущего состояния (версии) в замиченной области
$git checkout e14h --nameFile                 - достанет nameFile в состоянии коммита в хеше e14h - 4 символа первых с названия
$ git commit -m "fix nameFile"                - после извлечения файла коммитим рабочую область 

//откат последнего коммита до предыдущего коммита 
$git revert HEAD                              - откатит последний коммит на который указывает HEAD на коммит назад
HEAD = равен названию хеша и можно использовать вместо e14h - 4 символа первых с названия хеша
HEAD~ предыдущий хеш коммита на который указывал HEAD
HEAD~2 хеш пред пред послкдний коммит на который указывал HEAD

$git log --oneline                             - выведет все коммиты в сокращенном названии
$git rev-parse HEAD                            - покажет полный хеш последнего коммита на который указывает HEAD

//откат последнего коммита путем перемещения HEAD с Master одновременно 
$git reset --soft HEAD~                        - перенесет HEAD с Master на предпоследний коммит, последний выведется из под коммита будет в состоянии (stoged)
$git reset --mix HEAD~                         - перенесет HEAD с Master на предпоследний коммит, последний выведется из под коммита и индекса будет в состоянии (modifided)
$git reset --hard HEAD~                        - перенесет HEAD с Master на предпоследний коммит, последний коммит безповоротно будет удален

//удаление файлов в рабочей дерриктории
$git clean --force                             - будут удалены все файлы в рабочей дерриктории в состоянии (modifided)
